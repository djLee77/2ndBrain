[[제출용 소감문]]

이번주차 미션에서는 어떤 부분에서 더 노력하여 개선할 수 있는 부분이 있는지에 대한 인지와 실제로 노력했던 주차였다.
이전에는 구현의 완성을 목표로 했었는데, 더 나은 코드를 목표 하다 보니 훨씬 많은 시간을 소비하고 전보다 많이 나아진 것 같았지만 아쉽기도 더 아쉬웠다. 특히 객체 구조를 더 타당하게 짜지 못한 것이 많이 아쉬웠다.


여태까지 Class가 객체라는 사실은 알고 있었지만 Object를 칭할 때 말하는 객체와 Class를 칭할때 말하는 객체는 유의어 정도일 뿐 같은 의미가 아니라고 인지해왔다.

그런데 사실은 Class가 말그대로 객체를 생성하기 위한 템플릿이었다니 놀랍다.

---

Todo : Eslint, Prettier 적용하기

기능 목록 제시되어있지 않은 부분에 대해서도 고민하기

확장팩으로 설치하면 npm install을 통해 따로 설치하지 않아도 되는거야?

아닙니다, 확장 팩과 npm 패키지는 서로 다른 목적을 가지고 있습니다.

### npm 패키지 설치

`npm install`을 통해 설치하는 것은 해당 프로젝트의 종속성(dependencies)을 설치하는 것입니다. ESLint와 Prettier를 프로젝트에 설치하는 것은 실제 코드를 분석하고 포맷하는 기능을 프로젝트에 추가하는 것입니다. 이렇게 설치된 패키지는 프로젝트 내에서 실행되며, 커맨드 라인 또는 다른 스크립트를 통해 사용됩니다.

### 에디터 확장 팩 설치

에디터 확장 팩(Visual Studio Code의 경우 확장 프로그램)은 코드를 작성하는 동안 실시간으로 ESLint와 Prettier 기능을 적용하는 데 도움을 줍니다. 이는 에디터의 사용성을 개선하기 위한 것으로, 개발자가 코드를 입력할 때 오류를 바로 확인할 수 있게 하고, 코드를 저장할 때 자동으로 포맷을 적용할 수 있게 합니다.

### 함께 사용하는 이유

- **npm 패키지:** 이것은 프로젝트의 일부로, 모든 개발자가 동일한 룰셋과 버전의 ESLint와 Prettier를 사용하도록 합니다. 또한 Continuous Integration(CI)과 같은 자동화된 환경에서 사용할 수 있습니다.
- **에디터 확장 팩:** 개별 개발자가 코드를 작성하는 동안 실시간 피드백을 받고, 코드 스타일과 품질을 유지할 수 있도록 합니다.

둘 다 프로젝트에서 사용되길 권장되지만, npm 패키지는 프로젝트 설정의 일부로, 프로젝트와 함께 버전 관리 시스템에 포함되어야 합니다. 반면에 확장 팩은 사용자의 개인 에디터 설정의 일부로, 프로젝트에 직접적으로 포함되지는 않습니다.


그렇다.. eslint가 프로젝트 코드 단에서 사용하는 것이 아니라, 해당 VSCode라는 에디터에 적용해서 사용하는 것이다 보니, eslint를 사용하려면 eslint extension만 설치하거나, eslint library만 설치하는 것이 아니라, 둘 다 설치 및 세팅이 되어 있어야 하는 것이다.

javaScript 모듈을 가져오거나 내보낼 때, 파일 확장자 `.js`를 생략하는 것은 ES6 모듈 스펙에 포함되어 있으며, 대부분의 모던 자바스크립트 환경과 번들러(예: webpack, Rollup, Parcel)에서 지원합니다. 그래서 eslint가 확장자명을 지우라고 경고했다. 하지만, Node.js에서는 확장자를 명시해야 할 때도 있습니다.

---

플로우 차트를 그리는 draw.io에 대해서 처음 알게 되었다.
깃허브 리포지토리와 연동되어서 플로우 차트를 그리고 저장할 때마다 커밋 메시지를 작성하고 리포지토리에 직접 커밋하여 리포지토리에 이미지가 생성되고 수정도 되는데 너무 편리해서 깜짝 놀랐다.

만약에 플로우차트를 그리고 이미지를 저장하고 깃허브에 업로드 한 뒤, 로컬에서 pull받고 리드미에 첨부하는 방식을 사용했다면,
플로우차트를 수정할 때 마다 위 과정을 반복했을 것이다.

---
도메인 로직이 뜻하는 말을 처음 알았다
# 이 코드는 현실 문제에 대한 의사결정을 하고 있는가?

도메인 로직과 어플리케이션 서비스 로직을 구분하는 하나의 척도는, 바로 '비즈니스 의사결정'이다.

> 이 코드가 현실 문제, 즉 비즈니스에 대한 의사결정을 하고 있는가?

이거 하나만 기억하면 된다.

도메인 로직은 현실 문제에 대한 의사결정을 하는 코드다. 나머지 코드는 그 결정을 위한 입력값을 만들어주거나, 그 결정의 결과물을 해석하고 보여주고 전파하는 코드다.

---
필드란 무엇인가?

필드(Field)는 클래스, 구조체, 인터페이스 또는 어떤 데이터 구조체에 포함된 변수나 데이터를 말합니다. 객체 지향 프로그래밍에서 필드는 클래스의 특정한 인스턴스에 대한 정보를 담고 있는 속성(attribute)이나 상태(state)를 저장합니다.

예를 들어, 자바스크립트의 `class` 구문에서 필드는 다음과 같이 정의됩니다:

javascriptCopy code

`class MyClass {   myField; // 이것은 클래스의 필드입니다.    constructor(value) {     this.myField = value; // 인스턴스를 생성할 때 myField 필드를 초기화합니다.   } }`

필드는 일반적으로 객체의 현재 상태를 나타내며, 메서드는 이러한 필드를 사용하여 객체가 어떤 행동을 하도록 설계됩니다. 필드는 다음과 같은 특징을 가질 수 있습니다:

- **접근 제어자(Access Modifiers):** 필드는 공개(public), 보호(protected), 비공개(private)와 같은 접근 제어자를 사용하여 해당 필드가 어디에서 접근 가능한지 제한할 수 있습니다. 예를 들어, 자바스크립트에서는 `#`을 붙여 비공개 필드를 선언할 수 있습니다.
- **정적 필드(Static Fields):** 어떤 필드는 클래스 레벨에서 정적(static)으로 선언될 수 있으며, 이러한 필드는 해당 클래스의 모든 인스턴스에 대해 공유됩니다.
- **인스턴스 필드(Instance Fields):** 각각의 객체 인스턴스는 자신만의 복사본을 가지는 인스턴스 필드를 가질 수 있습니다.

우테코 프리코스 미션에서 언급된 "Lotto에 필드를 추가할 수 없다"는 지시는, 이 `Lotto` 클래스의 인스턴스가 가질 수 있는 속성을 오직 `#numbers`로 제한한다는 것을 의미합니다. 여기서 `#numbers` 필드는 비공개 필드로, 클래스 외부에서는 접근할 수 없으며, `Lotto` 클래스의 메서드를 통해서만 조작할 수 있습니다.


따라서
"Lotto에 필드를 추가할 수 없다"는 요구 사항은 제공된 `Lotto` 클래스의 구조를 변경하지 않고, 즉 새로운 속성(필드)을 이 클래스에 추가하지 말라는 것을 의미합니다. 즉, 이미 정의된 `#numbers` 이외에 `Lotto` 클래스에 새로운 속성을 추가하는 것이 금지되어 있다는 것입니다.

`Lotto` 클래스에는 `#numbers`라는 하나의 필드만이 정의되어 있고, 이 필드는 클래스의 private 속성입니다. JavaScript에서 `#` 접두사는 해당 필드가 클래스 내부에서만 접근 가능하고 클래스의 외부에서는 접근할 수 없도록 하는 것을 나타냅니다.

이런 종류의 요구 사항은 설계상의 의도를 반영하고 있습니다. `Lotto` 클래스가 로또 번호들만을 저장하도록 제한함으로써, 객체의 책임을 명확하게 하고, 이 클래스를 사용하는 다른 부분의 코드에서 필요한 처리를 강제하는 것입니다. 추가적인 상태 관리가 필요한 경우, 해당 상태를 다루는 새로운 클래스나 함수를 만들거나, 기존 메서드 내에서 지역 변수를 사용하여 처리해야 합니다.

이 요구 사항을 준수하는 한에서 `Lotto` 클래스 내에 새로운 메서드를 추가하거나, 기존 메서드를 수정하는 것은 가능할 수 있습니다. 단, 이때도 주어진 `#numbers` 필드 이외의 추가적인 상태를 `Lotto` 클래스에 저장하는 것은 허용되지 않습니다.

개발을 진행할 때, 이러한 제한은 종종 클래스의 단일 책임 원칙(Single Responsibility Principle)을 유지하고, 코드의 복잡성을 관리하기 위해 부과됩니다.

---

플로우차트를 자세히 설계해 놓으니 구현이 술술 된다. 개발이 너무 재밌다.

---

미션의 크기가 커지니 점점 변수명과 메서드명의 타당성이 부족하게 네이밍을 했던 것 같아 아쉬웠다.

그리고 메서드별 온전히 하나의 기능만을 수행하도록 구현하지 못했던 것 같았다 

---

부분 커밋 하는 법을 처음 알았어요 - 커밋의 동작 과정에 대한 완전한 이해 없이 수행해왔던 것이 문제였다.

---

객체 구조를 더 타당하게 짜기 위해서 노력한 것이 무엇이냐면, 예를 들면 당첨 결과를 판단하는 메서드가 포함된 클래스를 인스턴스 생성할 때 생성자에 인자로 당첨 번호와 로또 번호를 넘겨줬었다면, 로또 객체를 생성하는데 당첨 번호를 알고 있는 것이 타당하지 않다고 생각되어, 생성자의 인자로는 로또 번호만 받고, 당첨 결과를 판단하는 메서드의 인자로 직접 당첨 번호를 넘겨주는 방식으로 리팩토링했다.(커밋 번호 7318770)


그리고 메서드별 온전히 하나의 기능만을 수행하도록 구현하지 못했던 것 같았다 

다음 주차 부터는 완전한 객체 지향을 위해 해당 객체의 데이터를 외부에 노출시키지 않고 해당 객체 내에서 프로세스를 수행하도록
목표
ex) lotto의 reward를 출력하기 위해서는 lotto 클래스 내에서 출력 메서드 구현
