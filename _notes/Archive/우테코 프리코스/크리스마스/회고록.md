위에서 제시된 두 코드 사이에는 몇 가지 주요한 차이점이 있습니다. 하나는 객체 리터럴을 사용하여 정의된 것이고, 다른 하나는 클래스를 사용하여 정의된 것입니다.

1. **객체 리터럴 사용:**
    
    javascriptCopy code
    
    `const InputView = {   async readDate() {     // ...   },   // ... };  export default InputView;`
    
    이 코드에서 `InputView`는 객체 리터럴을 사용하여 만들어진 단순한 객체입니다. 객체 리터럴은 정적인 속성과 메소드를 가질 수 있지만, 클래스 기반의 상속이나 인스턴스 생성 같은 기능은 제공하지 않습니다. 객체 리터럴 방식은 단순한 구조를 가지고 있으며, 주로 고정된 데이터나 유틸리티 함수를 그룹화할 때 사용됩니다.
    
2. **클래스 사용:**
    
    javascriptCopy code
    
    `class InputView {   async readDate() {     // ...   },   // ... };  export default InputView;`
    
    여기서 `InputView`는 클래스로 정의됩니다. 클래스를 사용하면 객체 지향 프로그래밍의 모든 이점을 활용할 수 있습니다. 이것은 인스턴스를 생성하고, 상속을 통해 다른 클래스로 확장하며, 생성자 메소드를 통해 인스턴스 초기화를 수행할 수 있음을 의미합니다. 클래스는 더 복잡한 구조를 가진 객체를 만들 때 유용하며, 다형성, 캡슐화, 상속 등의 객체 지향 프로그래밍 개념을 구현하는 데 적합합니다.
    

**요약하자면:**

- 객체 리터럴 방식은 더 단순하고 정적인 구조에 적합합니다.
- 클래스 방식은 더 복잡하고 동적인 객체를 만드는 데 적합하며, 객체 지향 프로그래밍의 모든 기능을 제공합니다.

파일로 만들고 다른 곳에서 import 하기 위해서는 반드시 class로 선언해야 되는 줄 알았는데 클래스가 객체를 생성하는 템플릿이라는 것을 깨닫고 나니 결국 객체도 export가 가능하다는 것까지 생각이 도달했다.

---

3주차에서는 상수들을 보기 좋게 정리하려는 과정에서 Object에 담는 바람에 정작 중요한 const의 불변성을 고려하지 않았었다. 그래서 이번 미션에서는 Object.freeze를 사용해서 객체에 담는 동시에 const의 불변성도 유지했다.


----
**원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다**.

---

정규표현식을 이용한 유효성 검사

---

아쉬운 점은 MVC 패턴에 익숙해지기 바빠서 목표했던 private 키워드 사용은 못해본 것이다.